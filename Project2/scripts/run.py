"""
@file run.py
@brief Driver script for Project 2 experiments.

This script runs the Project 2 C executable multiple times while
modifying the configuration file for each run and aggregating results.

Responsibilities are split as follows:

C Program Responsibilities:
- Executes a single problem
- Uses one problem dimension
- Executes one algorithm
- Writes results to a CSV file

Python Script Responsibilities:
- Loops over multiple runs
- Modifies configuration values per run
- Aggregates CSV output
- Computes fitness and runtime statistics
"""

import argparse
import csv
import subprocess
import tempfile
import time
from pathlib import Path
from statistics import mean, stdev, median


def read_cfg_lines(cfg_path):
    """
    @brief Reads all lines from a configuration file.

    @param cfg_path Path to the configuration file.
    @return A list of strings representing lines in the config file.
    """
    with open(cfg_path, "r", encoding="utf-8") as f:
        return f.read().splitlines()


def set_cfg_value(lines, key, value):
    """
    @brief Sets or updates a key-value pair in configuration file lines.

    If the key exists, its value is replaced. If it does not exist,
    the key-value pair is appended to the configuration.

    @param lines List of configuration file lines.
    @param key Configuration key to modify.
    @param value Value to assign to the key.
    @return Updated list of configuration lines.
    """
    key = key.lower()
    out = []
    found = False

    for line in lines:
        if "=" in line and not line.strip().startswith("#"):
            k, _ = line.split("=", 1)
            if k.strip().lower() == key:
                out.append(f"{k.strip()}={value}")
                found = True
            else:
                out.append(line)
        else:
            out.append(line)

    if not found:
        out.append(f"{key}={value}")

    return out


def write_cfg(lines, path):
    """
    @brief Writes configuration lines to a file.

    @param lines List of configuration lines.
    @param path Output file path.
    """
    with open(path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")


def run_once(exe, cfg_path):
    """
    @brief Executes the C program once using the given configuration file.

    @param exe Path to the executable.
    @param cfg_path Path to the configuration file.
    @throws RuntimeError if the program exits with a non-zero status.
    """
    result = subprocess.run([exe, cfg_path])
    if result.returncode != 0:
        raise RuntimeError(f"Run failed (code={result.returncode})")


def read_run_csv(path):
    """
    @brief Reads fitness values and runtime from a single run CSV file.

    @param path Path to the CSV file generated by the C program.
    @return A tuple containing:
            - List of fitness values
            - Runtime in milliseconds
    """
    fitness = []
    time_ms = None

    with open(path, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            fitness.append(float(row["fitness"]))
            if time_ms is None:
                time_ms = float(row["time_ms"])

    return fitness, time_ms


def main():
    """
    @brief Main entry point for running and aggregating experiments.

    This function:
    - Parses command-line arguments
    - Runs the executable multiple times
    - Modifies the configuration per run
    - Aggregates results into a master CSV
    - Computes summary statistics
    """
    ap = argparse.ArgumentParser()
    ap.add_argument("--exe", required=True)
    ap.add_argument("--config", required=True)
    ap.add_argument("--runs", type=int, default=30)
    ap.add_argument("--out", default="data/project2_master.csv")
    args = ap.parse_args()

    exe = args.exe
    base_cfg = args.config
    runs = args.runs
    master_csv = Path(args.out)

    base_lines = read_cfg_lines(base_cfg)

    all_fitness = []
    all_times = []

    with tempfile.TemporaryDirectory() as tmp:
        tmp = Path(tmp)

        for r in range(runs):
            run_cfg = tmp / f"run_{r}.cfg"
            run_csv = tmp / f"run_{r}.csv"

            lines = list(base_lines)
            lines = set_cfg_value(lines, "output", run_csv)
            lines = set_cfg_value(lines, "seed", int(time.time()) + r)

            write_cfg(lines, run_cfg)

            print(f"Saving. . . {r+1}/{runs}")
            run_once(exe, run_cfg)

            fitness, t_ms = read_run_csv(run_csv)

            all_fitness.extend(fitness)
            all_times.append(t_ms)

            with open(master_csv, "a", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                if f.tell() == 0:
                    writer.writerow(["run", "fitness", "time_ms"])
                for v in fitness:
                    writer.writerow([r, v, t_ms])

    f_min = min(all_fitness)
    f_max = max(all_fitness)
    f_range = f_max - f_min

    print("\n=== Fitness statistics ===")
    print(f"Mean:   {mean(all_fitness):.3f}")
    print(f"Median: {median(all_fitness):.3f}")
    print(f"Range:  {f_range:.3f}")
    print(f"StdDev: {stdev(all_fitness):.3f}")

    print("\n=== Runtime statistics ===")
    print(f"Runs: {len(all_times)}")
    print(f"Avg:  {mean(all_times):.3f} ms")
    print(f"Min:  {min(all_times):.3f} ms")
    print(f"Max:  {max(all_times):.3f} ms")

    print(f"\nMaster CSV written to {master_csv}")


if __name__ == "__main__":
    main()
